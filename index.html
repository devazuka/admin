<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:image/svg+xml,<svg viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'><path fill='%23fff' stroke='%23888' d='M39,1L20.5,11L20.5,39L39,29Z'/><path fill='%23888' stroke='%23fff' d='M1,1L19.5,11L19.5,39L1,29Z'/></svg>">
  <title>Admin</title>
<style>
/* latin */
@font-face {
  font-family: 'Inconsolata';
  font-style: normal;
  font-weight: 400;
  font-stretch: 75%;
  src: url(https://fonts.gstatic.com/s/inconsolata/v30/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmXQLYxYWI2qfdm7Lpp4U8WR32lw.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

/* latin */
@font-face {
  font-family: 'Inconsolata';
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/inconsolata/v30/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
body {
  margin: 0 auto;
}

body, span {
  font-family: 'Inconsolata', monospace;
}

h1 { text-align: center }
.data {
  display: grid;
  border-right: 1px solid black;
}

.data > b[data-sort=asc] {
  background:
    linear-gradient(45deg, transparent 25%, #70f 0), 
    linear-gradient(-45deg, transparent 80%, #70f 0),
    linear-gradient(to bottom, transparent 65%, #70f 65%),
    #fff;
}
.data > b[data-sort=desc] {
  color: black;
  background:
    linear-gradient(45deg, #f70 20%, transparent 0), 
    linear-gradient(-45deg, #f70 75%, transparent 0),
    linear-gradient(to top, transparent 65%, #f70 65%),
    #000;
}

.data > span.Boolean:after { content: 'âœ˜' }
.data > span.Boolean[data-val='true']:after { content: 'âœ”' }
.data > span.Boolean.sex:after { content: 'âš§ï¸' }
.data > span.Boolean.sex[data-val='true']:after { content: 'â™‚ï¸' }
.data > span.Boolean.sex[data-val='false']:after { content: 'â™€ï¸' }

.data > span, .data > b {
  padding: 8px 4px;
  white-space: nowrap;
  text-align: center;
  display: inline-flex;
  justify-content: center;
  align-items: center;
}
.data > span.Date, .data > b.sex {
  font-stretch: 75%;
}
.data > span {
  border-left: 1px solid black;
  border-bottom: 1px solid black;
}

.data > span.even {
  background: rgba(0,0,0,.1);
}

.data > span:target {
  background: #70f;
  color: white;
}

.data > span.empty:after { content: '-' }

.data > span.image { padding: 0 }
.data > span.image:hover > img {
  height: unset;
  position: absolute;
  pointer-events: none;
}
.data > span.image > img { height: 4em }
.data > span.image:not(.empty):hover { height: 4em }

.data > b {
  background: black;
  color: white;
  user-select: none;
  cursor: default;
}

.data > *.hidden {
  width: 0px;
  overflow: hidden;
  border: 0;
  padding: 0;
  outline: none;
  margin-right: -1px;
}
main {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-evenly;
}
main.has-selection .data > span { display: none }
main.has-selection .data > span.selected { display: inline-flex }
</style>
</head>
<body>
  <h1>Admin</h1>
  <main></main>
  <script>
const CONTENT = document.querySelector('main')

const f2 = n => n < 10 ? ('0'+n) : n
const units = [
  ['year', 31536000000],
  ['month', 2628000000],
  ['day', 86400000],
  ['hour', 3600000],
  ['minute', 60000],
  ['second', 1000],
]

const rtf = new Intl.RelativeTimeFormat('en', { style:'narrow'})
const relatime = elapsed => {
  for (const [unit, amount] of units) {
    if (Math.abs(elapsed) > amount || unit === 'second') {
      return rtf.format(Math.round(elapsed/amount), unit)
    }
  }
}

const call = f => f()
const everySecondSub = new Set
const triggerUpdates = () => {
  requestAnimationFrame(() => everySecondSub.forEach(call))
  setTimeout(triggerUpdates, 1000)
}
triggerUpdates()
const formatTime = (start, end) => {
  const elem = document.createElement('time')
  const d = new Date(start)
  const time = f2(d.getHours()) +':'+ f2(d.getMinutes()) +':'+ f2(d.getSeconds())
  const date = f2(d.getDate()) +'-'+ f2(d.getMonth()+1) +'-'+ f2(d.getFullYear())
  elem.title = (elem.dateTime = `${date} ${time}`)
  if (end) {
    const text = relatime(end - start)
    elem.append(text.slice(3, -1))
  } else {
    let prevValue = relatime(Date.now() - d.getTime())
    const text = document.createTextNode(prevValue)
    everySecondSub.add(() => {
      const value = relatime(d.getTime() - Date.now())
      if (value === prevValue) return
      text.nodeValue = (prevValue = value)
    })
    elem.append(text)
  }
  return elem
}
const columnTypeDefs = {
  Date: {
    format: ts => formatTime(ts),
  },
  String: {
    format: (s, name) => {
      if (!s) return
      if (name !== 'image') return s
      const img = document.createElement('img')
      img.src = s
      return img
    }
  },
  Number: {
    format: (n, name) => {
      if (n == null) return
      if (name === 'amount') return `${(n / 100).toFixed(2)}â‚¬`
      return String(n)
    },
  },
  Boolean: { format: v => '', width: '2em' },
  JSON: { format: JSON.stringify },
}

const specialColumns = {
  image: {
    format(src) {
      if (!src) return
      const img = document.createElement('img')
      img.src = src
      return img
    },
  },
  amount: {
    alias: 'â‚¬',
    format: n => `${(n / 100)}â‚¬`,
  },
  refunded: { alias: 'â™»ï¸' },
  disputed: { alias: 'ðŸ‘©â€âš–ï¸' },
  croissant: {
    alias: ' ',
    format(v) {
      if (!v) return 'ðŸ’³'
      const span = document.createElement('span')
      span.title = v
      span.append('ðŸ¥')
      return span
    }
  },
  createdAt: {
    hidden: true,
    alias: 'saved',
  },
  updatedAt: {
    hidden: true,
    alias: 'changed',
  },
  end: {
    alias: 'time',
    format(v, name, type, data) {
      const span = document.createElement('span')
      const duration = formatTime(data.at, v)
      console.log({ v })
      span.append(v ? '' : 'ðŸŸ¢ ', duration)
      return span
    }
  },
  tax: { hidden: true },
  type: { hidden: true },
  product: { hidden: true },
  status: { hidden: true },
  status: { hidden: true },
}

const ENTITY = new Map()
const getAllRelated = (entity, collected = new Set) => {
  collected.add(entity)
  for (const id of entity.relateTo) {
    const relatedEntity = ENTITY.get(id)
    if (!relatedEntity || collected.has(relatedEntity)) continue
      getAllRelated(relatedEntity, collected)
  }
  return collected
}

const opClass = (entity, key, name) => entity && [...getAllRelated(entity)]
  .flatMap(e => e.elems)
  .forEach(elem => elem.classList[key](name))

let previous
const handleUpdateHash = () => {
  const selected = location.hash.split(/^#select-([0-9]+)$/)[1]
  const entity = ENTITY.get(Number(selected))
  if (entity === previous) return
  CONTENT.classList.toggle('has-selection', Boolean(entity))
  opClass(entity, 'add', 'selected')
  opClass(previous, 'remove', 'selected')
  previous = entity
}
addEventListener('hashchange', handleUpdateHash)

const entityDefs = {
  name: '#',
  format(v) {
    const a = document.createElement('a')
    const hash = `#select-${v}`
    a.href = hash
    a.onclick = (e) => {
      if (location.hash !== hash) return
      e.preventDefault()
      location.hash = '#'
    }
    a.append(`#${v}`)
    return a
  }
}

const refDefs = {
  isRef: true,
  format(v, name, type) {
    if (!v) return v
    const a = document.createElement('a')
    const b = document.createElement('b')
    b.append(v)
    a.append('#', b)
    a.href = `#${v}`
    a.title = `${type}#${v}`
    return a
  },
}

const prepareColumn = ([name, type], index) => {
  const def = index
    ? ({ ...(columnTypeDefs[type] || refDefs), ...specialColumns[name] })
    : entityDefs

  return { width: 'min-content', type, index, name, ...def }
}

// TODO: add filter
const makeFilter = q => new Function(['data', 'i', 'all'], `with (data) { return ${q} }`)
const createTable = table => {
  const wrapper = document.createElement('div')
  const title = document.createElement('h2')
  const div = document.createElement('div')
  wrapper.id = table.name
  title.append(table.name)
  div.classList.add('data')
  wrapper.append(title, div)

  const columns = Object.entries(table.columns).map(prepareColumn)
  const size = columns.length
  div.classList.add(`column-${size}`)
  let sorts = {}
  for (const { name, type, alias, hidden } of columns) {
    const b = document.createElement('b')
    b.classList.add(name, type)
    b.classList.toggle('hidden', Boolean(hidden))
    b.append(alias || name)
    b.addEventListener('click', () => {
      if (sorts.name !== name) {
        sorts.b && (sorts.b.dataset.sort = '')
        sorts.name = name
        sorts.b = b
      }
      sorts.order = b.dataset.sort =
          b.dataset.sort === 'asc' ? 'desc'
        : b.dataset.sort === 'desc' ? ''
        : 'asc'
      sort()
    })
    div.append(b)
  }

  div.style.gridTemplateColumns = columns.map(c => c.width).join(' ')
  let row = -1, col = -1
  const rows = table.data
  const maxRow = rows.length
  const unsortedData = Array(maxRow)
  while (++row < maxRow) {
    const data = rows[row]
    col = -1
    const relateTo = new Set()
    const rowSpans = Array(size)
    const rowData = { elems: rowSpans, relateTo }
    unsortedData[row] = rowData
    const id = data[0]
    ENTITY.set(id, rowData)
    while (++col < size) {
      const { name, format, type, isRef, hidden } = columns[col]
      const span = document.createElement('span')
      const val = data[col]
      isRef && relateTo.add(val)
      span.id = col ? `${name}-${id}` : id
      span.classList.add(name, type)
      span.classList.toggle('hidden', Boolean(hidden))
      span.dataset.val = val
      span.dataset.row = row
      span.dataset.col = col
      span.dataset.id = id
      const formatted = format(val, name, type, rowData)
      formatted == null
        ? span.classList.add('empty')
        : span.append(formatted)
      rowData[name] = val
      rowSpans[col] = span
    }
  }
  const show = (data) => {
    const { length } = data
    let row = -1
    while (++row < maxRow) {
      const { elems } = data[row]
      const par = row % 2 ? 'odd' : 'even'
      let col = -1
      while (++col < size) {
        const elem = elems[col]
        elem.dataset.par = par
        div.append(elem)
      }
    }
  }

  const compare = orderCompare => (adata, bdata) => {
    const a = adata[sorts.name]
    const b = bdata[sorts.name]
    if (a == b) return 0
    if (a == null) return 1
    if (b == null) return -1
    return orderCompare(a, b)
  }

  const compareASC = compare((a, b) => String(a).localeCompare(b))
  const compareDESC = compare((a, b) => String(b).localeCompare(a))

  const sortedData = [...unsortedData] // preserve the original order
  const sort = () => show(sorts.name
    ? sortedData.sort(sorts.order === 'asc' ? compareASC : compareDESC)
    : unsortedData)
  sort()
  CONTENT.append(wrapper)
}

const buildRelation = () => {
  for (const [id, { relateTo }] of ENTITY) {
    for (const relatedId of relateTo) {
      ENTITY.get(relatedId)?.relateTo.add(id)
    }
  }
}

fetch('/api/all').then(r => r.json()).then(tables => {
  for (const [name, { definitions, values }] of Object.entries(tables)) {
    createTable({
      name,
      columns: definitions,
      data: values,
    })
  }
  buildRelation()
  handleUpdateHash()
})

  </script>
</body>
</html>
